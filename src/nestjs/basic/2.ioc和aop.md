
# IOC
Inverse of Control（控制反转）
后端都是面向对象的开发方式，拿nestjs举例：
- 1、Controller 对象：接收 http 请求，调用 Service，返回响应
- 2、Service 对象：实现业务逻辑
- 3、Repository 对象：实现对数据库的增删改查
- 4、DataSources数据库链接对象
- 4、Config对象
这些对象直接都有关系，比如`Controller`对象依赖`Service`实现逻辑，`DataSources`对象又要从`Config`拿到数据库的信息等等。  
你在用`Controller`对象之前，需要先实例化`Service`对象，各种前后顺序，依赖关系，如果人为保证的话，很容易乱。IOC就是解决这个依赖问题。

## IOC原理
IOC原理就是把创建对象，处理对象之间的依赖关系等，放到了框架层面去处理，我们在写代码的时候，只要声明清楚相关的对象，对象之间的依赖关系就行。能干成这件事，就依赖上一节讲的`装饰器`。  
```ts
// 指定路由前缀user
@Injectable()
export class UserService {
  getHello() {
    return 'hello wrold'
  }
}

@Controller('user')
export class UserController {

  // 注入UserService
  @Inject(UserService)
  private readonly userService: UserService;

  // 申明一个register路由，访问/user/register是返回success
  @Post('register')
  register(@Body() registerUser: any) {
    return this.userService.getHello();
  }
}
```
如果要自己写，实现同样的功能代码如下：
```ts
const express = require('express');

const app = express();
const port = 3001;

class UserService {
  getHello() {
    return 'hello wrold'
  }
}

class UserController {
  prefix;
  userService
  constructor(prefix) {
    this.prefix = prefix;
  }

  userService = new UserService();
  
  register() {
    return this.userService.getHello()
    
  }
}
const userController = new UserController('/user');
app.post(`${userController.prefix}/register`, (req, res) => {
  console.log('register', userController.register())
  res.send(userController.register())
})

app.listen(port, () => {
  console.log('服务已启动')
})
```
上面代码只是一个简单的还原，正常会封装一下，比这个好点，但是也能看出和使用`IOC`的`nest`区别，不用`IOC`的话你需要自己去关注什么时候`new`对象，对象的前后顺序等，而使用`nestjs`你只需要声明清楚依赖关系，`nestjs`背后会根据装饰器里的数据，去进行依赖关系的处理，对象的`new`等。这就是`IOC`的作用。java里的注解也是这个。

# AOP
`nestjs`还有个重要的概念叫`AOP`，Aspect Oriented Programming面相切面编程。个人的理解就是在你正常的执行逻辑中间插入一些`API`方便你进行一些额外的操作。
